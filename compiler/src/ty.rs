use crate::interner::Symbol;

#[derive(Copy, Clone, PartialEq)]
/// These are guaranteed to be unique since they are generated by the disjoint set based on the
/// number of types that already exist
pub struct TypeId(pub usize);

#[derive(Debug)]
pub enum Ty {
    Int,
    String,
    Bool,
    Float,
    /// Type constructor that maps from Vec<Ty> -> Ty
    Fn(Vec<Self>, Box<Self>),
    /// Anything that isn't a primitive type
    Var(Symbol, TyId),
    /// Constructors that when given types construct other types. For example Int would be a
    /// nullary constructor that when given no types produces an Int
    Constr(TyConstr),
}

/// A type constructor with paramaters to fill out where params.last is the output type and the
/// constructor transforms params[..params.length()-2] -> params[params.length()-1]
#[derive(Debug)]
pub struct TyConstr {
    pub name: Symbol,
    pub params: Vec<Ty>,
}

#[derive(Copy, Clone, PartialEq, Eq)]
pub struct TyVar(pub Symbol);

#[derive(strum::Display, strum::EnumIter)]
pub enum PTy {
    Int,
    Bool,
    Float,
    String,
}

impl PartialEq<Symbol> for Ty {
    fn eq(&self, other: &Symbol) -> bool {
        match self {
            Ty::Var(sym, _) => *sym == *other,
            Ty::Constr(ty_constr) => ty_constr.name == *other,
            _ => panic!(),
        }
    }
}
