use crate::interner::Symbol;

#[derive(Copy, Clone, PartialEq, Debug)]
/// These are guaranteed to be unique since they are generated by the disjoint set based on the
/// number of types that already exist. An internal implementation detail of `Ty`. The only way to
/// interface with types should be `Ty` wherever possible.
pub struct TypeId(pub usize);

#[derive(Debug)]
pub enum Ty {
    /// Anything that isn't a primitive type
    Var(Symbol, TypeId),
    /// Constructors that when given types construct other types. For example Int would be a
    /// nullary constructor that when given no types produces an Int
    Constr(TyConstr),
}

/// A type constructor with paramaters to fill out where params.last is the output type and the
/// constructor transforms params[..params.length()-2] -> params[params.length()-1]
#[derive(Debug)]
pub struct TyConstr {
    pub name: Symbol,
    pub params: Vec<TypeId>,
}

#[derive(Copy, Clone, PartialEq, Eq)]
pub struct TyVar(pub Symbol);

#[derive(strum::Display, strum::EnumIter)]
pub enum PTy {
    Int,
    Bool,
    Float,
    String,
}

// impl PartialEq<Symbol> for Ty {
//     fn eq(&self, other: &Symbol) -> bool {
//         match self {
//             Ty::Var(sym, _) => *sym == *other,
//             Ty::Constr(ty_constr) => ty_constr.name == *other,
//             _ => panic!(),
//         }
//     }
// }
